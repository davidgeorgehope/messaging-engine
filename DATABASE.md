# Messaging Engine Database Schema

## Overview

The database uses SQLite managed through Drizzle ORM. All schema definitions live in `src/db/schema.ts` and migrations are handled via Drizzle Kit. The schema consists of 14 tables covering the full pipeline lifecycle from discovery through approved messaging assets.

### Conventions

- **Primary Keys**: All tables use `TEXT` primary keys generated by `generateId()` (nanoid-style, 21 characters). Never use auto-increment integers.
- **Timestamps**: All datetime fields use ISO 8601 format stored as `TEXT`. Always use `new Date().toISOString()` when inserting.
- **JSON Columns**: Complex nested data (arrays, objects) is stored as `TEXT` with JSON serialization. Parse with `JSON.parse()` on read, `JSON.stringify()` on write.
- **Soft Deletes**: Most tables use a `status` field rather than hard deletes. Status values vary by table but typically include `active`, `archived`, or `deleted`.
- **Audit Fields**: All tables include `created_at` and `updated_at` timestamps.

---

## Table Definitions

### 1. `messaging_priorities`

Defines the strategic messaging priorities that guide discovery and generation. These are the top-level themes the PMM team wants messaging for.

**Origin**: New table (not in o11y.tips or compintels).

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | Unique identifier via `generateId()` |
| `name` | TEXT | NOT NULL | Short name for the priority (e.g., "Kubernetes Observability") |
| `description` | TEXT | NOT NULL | Detailed description of the priority area |
| `category` | TEXT | NOT NULL | Category grouping (e.g., "platform", "security", "cost") |
| `keywords` | TEXT | NOT NULL | JSON array of keywords used for discovery matching |
| `target_personas` | TEXT | NOT NULL | JSON array of target persona identifiers |
| `priority_rank` | INTEGER | NOT NULL, DEFAULT 0 | Numeric rank for ordering (lower = higher priority) |
| `status` | TEXT | NOT NULL, DEFAULT 'active' | One of: `active`, `paused`, `archived` |
| `created_at` | TEXT | NOT NULL | ISO 8601 creation timestamp |
| `updated_at` | TEXT | NOT NULL | ISO 8601 last update timestamp |

### 2. `discovery_schedules`

Configures how and when each community source is polled for new content. Forked from the o11y.tips source scheduling system.

**Origin**: Adapted from o11y.tips `source_schedules`.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | Unique identifier via `generateId()` |
| `source_type` | TEXT | NOT NULL | Source platform: `reddit`, `hackernews`, `discourse`, `stackoverflow`, `discord` |
| `source_config` | TEXT | NOT NULL | JSON object with source-specific config (subreddits, tags, channels, etc.) |
| `cron_expression` | TEXT | NOT NULL | node-cron expression defining poll frequency |
| `priority_id` | TEXT | REFERENCES messaging_priorities(id) | Optional link to a messaging priority for focused discovery |
| `enabled` | INTEGER | NOT NULL, DEFAULT 1 | Boolean flag (0/1) to enable/disable this schedule |
| `last_run_at` | TEXT | | ISO 8601 timestamp of last successful run |
| `last_error` | TEXT | | Last error message if the most recent run failed |
| `created_at` | TEXT | NOT NULL | ISO 8601 creation timestamp |
| `updated_at` | TEXT | NOT NULL | ISO 8601 last update timestamp |

### 3. `discovered_pain_points`

Stores every pain point discovered from community sources. Each row represents a single identifiable pain expressed by a practitioner. This is the primary input to the rest of the pipeline.

**Origin**: Adapted from o11y.tips `discovered_tips`.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | Unique identifier via `generateId()` |
| `schedule_id` | TEXT | NOT NULL, REFERENCES discovery_schedules(id) | Which schedule discovered this pain point |
| `priority_id` | TEXT | REFERENCES messaging_priorities(id) | Matched messaging priority (if any) |
| `source_type` | TEXT | NOT NULL | Platform where this was found |
| `source_url` | TEXT | NOT NULL | Direct URL to the original post/comment |
| `source_author` | TEXT | | Author username (anonymized if needed) |
| `source_date` | TEXT | | ISO 8601 date of the original post |
| `title` | TEXT | | Title of the source post (if applicable) |
| `raw_content` | TEXT | NOT NULL | Full raw text of the post/comment |
| `extracted_pain` | TEXT | NOT NULL | AI-extracted summary of the pain point |
| `extracted_quotes` | TEXT | NOT NULL | JSON array of verbatim quotes from the source |
| `pain_category` | TEXT | | Categorization of the pain (e.g., "complexity", "cost", "reliability") |
| `severity_score` | REAL | NOT NULL, DEFAULT 0 | AI-scored severity (0-100) |
| `relevance_score` | REAL | NOT NULL, DEFAULT 0 | AI-scored relevance to product (0-100) |
| `frequency_indicator` | TEXT | | Estimated frequency: `isolated`, `recurring`, `widespread` |
| `status` | TEXT | NOT NULL, DEFAULT 'new' | One of: `new`, `validated`, `used`, `irrelevant`, `archived` |
| `created_at` | TEXT | NOT NULL | ISO 8601 creation timestamp |
| `updated_at` | TEXT | NOT NULL | ISO 8601 last update timestamp |

### 4. `generation_jobs`

Tracks each messaging generation job. A job takes one or more pain points, combines them with product context and research, and produces messaging assets via Claude.

**Origin**: New table.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | Unique identifier via `generateId()` |
| `pain_point_ids` | TEXT | NOT NULL | JSON array of `discovered_pain_points` IDs used as input |
| `voice_profile_id` | TEXT | NOT NULL, REFERENCES voice_profiles(id) | Voice profile governing this generation |
| `asset_types` | TEXT | NOT NULL | JSON array of asset types to generate (e.g., `["battlecard", "talk_track"]`) |
| `product_doc_ids` | TEXT | | JSON array of `product_documents` IDs used as context |
| `research_ids` | TEXT | | JSON array of `competitive_research` IDs used as context |
| `generation_prompt` | TEXT | | The full assembled prompt sent to Claude (stored for traceability) |
| `model_id` | TEXT | NOT NULL | Model identifier used (e.g., "claude-sonnet-4-20250514") |
| `status` | TEXT | NOT NULL, DEFAULT 'pending' | One of: `pending`, `running`, `completed`, `failed`, `cancelled` |
| `error_message` | TEXT | | Error details if status is `failed` |
| `started_at` | TEXT | | ISO 8601 timestamp when generation began |
| `completed_at` | TEXT | | ISO 8601 timestamp when generation finished |
| `token_usage` | TEXT | | JSON object with input/output token counts |
| `created_at` | TEXT | NOT NULL | ISO 8601 creation timestamp |
| `updated_at` | TEXT | NOT NULL | ISO 8601 last update timestamp |

### 5. `settings`

Key-value store for system-wide configuration. Used for API keys, feature flags, default thresholds, and other runtime configuration.

**Origin**: Adapted from o11y.tips `settings`.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `key` | TEXT | PRIMARY KEY | Setting key (e.g., "gemini_api_key", "default_severity_threshold") |
| `value` | TEXT | NOT NULL | Setting value (may be JSON for complex values) |
| `description` | TEXT | | Human-readable description of the setting |
| `category` | TEXT | NOT NULL, DEFAULT 'general' | Grouping category: `general`, `ai`, `auth`, `scheduler`, `quality` |
| `is_secret` | INTEGER | NOT NULL, DEFAULT 0 | Boolean flag — if 1, value is masked in UI/API responses |
| `updated_at` | TEXT | NOT NULL | ISO 8601 last update timestamp |

### 6. `product_documents`

Stores uploaded product documents that provide factual context for messaging generation. Documents are parsed and chunked for retrieval.

**Origin**: New table.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | Unique identifier via `generateId()` |
| `name` | TEXT | NOT NULL | Document display name |
| `file_name` | TEXT | NOT NULL | Original uploaded file name |
| `file_type` | TEXT | NOT NULL | MIME type or extension (e.g., "application/pdf", "text/markdown") |
| `file_path` | TEXT | NOT NULL | Path to stored file on disk |
| `parsed_content` | TEXT | | Full parsed text content of the document |
| `chunks` | TEXT | | JSON array of content chunks for retrieval |
| `product_area` | TEXT | | Product area tag (e.g., "platform", "agent", "dashboard") |
| `document_type` | TEXT | NOT NULL | Type: `datasheet`, `release_notes`, `changelog`, `faq`, `positioning`, `other` |
| `version` | TEXT | | Document version string |
| `status` | TEXT | NOT NULL, DEFAULT 'active' | One of: `active`, `archived` |
| `created_at` | TEXT | NOT NULL | ISO 8601 creation timestamp |
| `updated_at` | TEXT | NOT NULL | ISO 8601 last update timestamp |

### 7. `messaging_assets`

The primary output table. Each row is a generated messaging asset (battlecard, talk track, etc.) with its current status in the review workflow.

**Origin**: New table (core to this project).

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | Unique identifier via `generateId()` |
| `generation_job_id` | TEXT | NOT NULL, REFERENCES generation_jobs(id) | Job that produced this asset |
| `asset_type` | TEXT | NOT NULL | Type: `battlecard`, `talk_track`, `launch_messaging`, `social_hook`, `one_pager`, `email_copy` |
| `title` | TEXT | NOT NULL | Asset title/headline |
| `content` | TEXT | NOT NULL | Full asset content (markdown formatted) |
| `summary` | TEXT | | Brief summary of the asset |
| `voice_profile_id` | TEXT | NOT NULL, REFERENCES voice_profiles(id) | Voice profile used for generation |
| `priority_id` | TEXT | REFERENCES messaging_priorities(id) | Linked messaging priority |
| `target_persona` | TEXT | | Target persona identifier |
| `overall_score` | REAL | DEFAULT 0 | Computed overall quality score (0-100) |
| `passed_quality_gate` | INTEGER | DEFAULT 0 | Boolean: whether asset passed all quality gate thresholds |
| `status` | TEXT | NOT NULL, DEFAULT 'draft' | One of: `draft`, `scoring`, `scored`, `in_review`, `approved`, `rejected`, `archived` |
| `reviewer_notes` | TEXT | | Notes from human reviewer |
| `reviewed_by` | TEXT | | User ID of reviewer |
| `reviewed_at` | TEXT | | ISO 8601 review timestamp |
| `created_at` | TEXT | NOT NULL | ISO 8601 creation timestamp |
| `updated_at` | TEXT | NOT NULL | ISO 8601 last update timestamp |

### 8. `persona_critics`

Defines the AI critic personas used in scoring. Each critic evaluates assets from a specific perspective (e.g., a skeptical developer, a time-pressed SRE, a budget-conscious VP).

**Origin**: Adapted from o11y.tips `quality_critics`.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | Unique identifier via `generateId()` |
| `name` | TEXT | NOT NULL, UNIQUE | Critic persona name (e.g., "Skeptical SRE") |
| `role` | TEXT | NOT NULL | Role description (e.g., "Senior SRE at a mid-size SaaS company") |
| `perspective` | TEXT | NOT NULL | Evaluation perspective and biases |
| `scoring_prompt` | TEXT | NOT NULL | System prompt used when this critic scores an asset |
| `weight` | REAL | NOT NULL, DEFAULT 1.0 | Weight multiplier for this critic's scores in overall calculation |
| `status` | TEXT | NOT NULL, DEFAULT 'active' | One of: `active`, `inactive` |
| `created_at` | TEXT | NOT NULL | ISO 8601 creation timestamp |
| `updated_at` | TEXT | NOT NULL | ISO 8601 last update timestamp |

### 9. `persona_scores`

Individual scores from each persona critic for each messaging asset, across each scoring dimension.

**Origin**: Adapted from o11y.tips `quality_scores`.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | Unique identifier via `generateId()` |
| `asset_id` | TEXT | NOT NULL, REFERENCES messaging_assets(id) | Asset being scored |
| `critic_id` | TEXT | NOT NULL, REFERENCES persona_critics(id) | Critic persona doing the scoring |
| `dimension` | TEXT | NOT NULL | Scoring dimension: `slop`, `vendor_speak`, `authenticity`, `specificity`, `persona_fit` |
| `score` | REAL | NOT NULL | Score value (0-100) |
| `reasoning` | TEXT | NOT NULL | AI-generated explanation of the score |
| `suggestions` | TEXT | | JSON array of improvement suggestions |
| `model_id` | TEXT | NOT NULL | Model used for scoring (e.g., "gemini-2.0-flash") |
| `created_at` | TEXT | NOT NULL | ISO 8601 creation timestamp |

### 10. `competitive_research`

Stores results from Gemini Deep Research competitive analysis jobs. Each row represents one research session focused on a specific pain point or topic.

**Origin**: Adapted from compintels `research_jobs`.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | Unique identifier via `generateId()` |
| `pain_point_id` | TEXT | REFERENCES discovered_pain_points(id) | Pain point that triggered this research |
| `priority_id` | TEXT | REFERENCES messaging_priorities(id) | Related messaging priority |
| `research_query` | TEXT | NOT NULL | The query/prompt sent to Gemini Deep Research |
| `competitor_names` | TEXT | | JSON array of competitor names to focus on |
| `raw_response` | TEXT | | Full raw response from Gemini Deep Research |
| `parsed_findings` | TEXT | | JSON object with structured findings |
| `competitor_positioning` | TEXT | | JSON object mapping competitor names to their positioning |
| `gaps_identified` | TEXT | | JSON array of competitive gaps found |
| `sources_cited` | TEXT | | JSON array of source URLs cited in the research |
| `gemini_job_id` | TEXT | | Gemini Deep Research job identifier for polling |
| `status` | TEXT | NOT NULL, DEFAULT 'pending' | One of: `pending`, `researching`, `completed`, `failed`, `expired` |
| `error_message` | TEXT | | Error details if status is `failed` |
| `started_at` | TEXT | | ISO 8601 research start timestamp |
| `completed_at` | TEXT | | ISO 8601 research completion timestamp |
| `created_at` | TEXT | NOT NULL | ISO 8601 creation timestamp |
| `updated_at` | TEXT | NOT NULL | ISO 8601 last update timestamp |

### 11. `asset_traceability`

The traceability chain linking each messaging asset back to all its source inputs. This is the table that powers the "killer feature" — full evidence tracing from asset back to community source.

**Origin**: New table (core differentiator of this project).

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | Unique identifier via `generateId()` |
| `asset_id` | TEXT | NOT NULL, REFERENCES messaging_assets(id) | The messaging asset |
| `pain_point_ids` | TEXT | NOT NULL | JSON array of `discovered_pain_points` IDs that informed this asset |
| `quotes_used` | TEXT | NOT NULL | JSON array of verbatim quotes incorporated from pain points |
| `product_doc_ids` | TEXT | | JSON array of `product_documents` IDs used as context |
| `product_facts_used` | TEXT | | JSON array of specific product facts pulled from documents |
| `research_ids` | TEXT | | JSON array of `competitive_research` IDs used as context |
| `competitive_claims` | TEXT | | JSON array of specific competitive claims incorporated |
| `voice_profile_id` | TEXT | NOT NULL, REFERENCES voice_profiles(id) | Voice profile used |
| `generation_prompt_hash` | TEXT | | SHA-256 hash of the generation prompt for change detection |
| `model_id` | TEXT | NOT NULL | Model used for generation |
| `model_parameters` | TEXT | | JSON object of model parameters (temperature, max_tokens, etc.) |
| `edit_history` | TEXT | | JSON array of edit events: `[{editor, timestamp, diff}]` |
| `created_at` | TEXT | NOT NULL | ISO 8601 creation timestamp |
| `updated_at` | TEXT | NOT NULL | ISO 8601 last update timestamp |

### 12. `messaging_gaps`

Tracks identified gaps in messaging coverage. A gap exists when pain points have been discovered but no adequate messaging asset addresses them, or when competitive research reveals unaddressed positioning opportunities.

**Origin**: New table.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | Unique identifier via `generateId()` |
| `pain_point_id` | TEXT | REFERENCES discovered_pain_points(id) | Pain point with insufficient messaging |
| `priority_id` | TEXT | REFERENCES messaging_priorities(id) | Related messaging priority |
| `gap_type` | TEXT | NOT NULL | Type: `uncovered_pain`, `weak_positioning`, `missing_asset_type`, `competitive_gap` |
| `description` | TEXT | NOT NULL | Description of the messaging gap |
| `severity` | TEXT | NOT NULL, DEFAULT 'medium' | Severity: `low`, `medium`, `high`, `critical` |
| `suggested_asset_types` | TEXT | | JSON array of asset types that could fill this gap |
| `related_asset_ids` | TEXT | | JSON array of existing asset IDs that partially cover this gap |
| `status` | TEXT | NOT NULL, DEFAULT 'open' | One of: `open`, `in_progress`, `addressed`, `wont_fix` |
| `addressed_by_asset_id` | TEXT | REFERENCES messaging_assets(id) | Asset that addressed this gap (when resolved) |
| `created_at` | TEXT | NOT NULL | ISO 8601 creation timestamp |
| `updated_at` | TEXT | NOT NULL | ISO 8601 last update timestamp |

### 13. `voice_profiles`

Defines the voice/tone profiles used to govern messaging generation and quality scoring thresholds.

**Origin**: New table.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | Unique identifier via `generateId()` |
| `name` | TEXT | NOT NULL, UNIQUE | Profile name (e.g., "Developer Advocate", "Enterprise Sales") |
| `description` | TEXT | NOT NULL | Description of the intended voice and audience |
| `tone_attributes` | TEXT | NOT NULL | JSON object: `{formality: 0-100, technical_depth: 0-100, empathy: 0-100, urgency: 0-100}` |
| `vocabulary_rules` | TEXT | NOT NULL | JSON object: `{preferred_terms: [], banned_terms: [], jargon_policy: "embrace\|explain\|avoid"}` |
| `quality_gates` | TEXT | NOT NULL | JSON object: `{slop: min_score, vendor_speak: min_score, authenticity: min_score, specificity: min_score, persona_fit: min_score}` |
| `example_snippets` | TEXT | | JSON array of example text snippets that exemplify this voice |
| `system_prompt_prefix` | TEXT | | Additional system prompt text injected during generation for this voice |
| `is_default` | INTEGER | NOT NULL, DEFAULT 0 | Boolean: whether this is the default voice profile |
| `status` | TEXT | NOT NULL, DEFAULT 'active' | One of: `active`, `inactive` |
| `created_at` | TEXT | NOT NULL | ISO 8601 creation timestamp |
| `updated_at` | TEXT | NOT NULL | ISO 8601 last update timestamp |

### 14. `asset_variants`

Stores alternate versions of messaging assets. When an asset is regenerated with different parameters, or when a human edits produce a new version, the variant is stored here while preserving the original.

**Origin**: New table.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | Unique identifier via `generateId()` |
| `original_asset_id` | TEXT | NOT NULL, REFERENCES messaging_assets(id) | The original/parent asset |
| `variant_type` | TEXT | NOT NULL | Type: `regeneration`, `voice_change`, `human_edit`, `deslop`, `a_b_test` |
| `title` | TEXT | NOT NULL | Variant title |
| `content` | TEXT | NOT NULL | Full variant content (markdown) |
| `voice_profile_id` | TEXT | REFERENCES voice_profiles(id) | Voice profile used (may differ from original) |
| `generation_params` | TEXT | | JSON object of parameters that differed from original |
| `overall_score` | REAL | DEFAULT 0 | Quality score for this variant |
| `is_preferred` | INTEGER | NOT NULL, DEFAULT 0 | Boolean: whether this variant has been selected as preferred over the original |
| `created_at` | TEXT | NOT NULL | ISO 8601 creation timestamp |
| `updated_at` | TEXT | NOT NULL | ISO 8601 last update timestamp |

---

## Relationship Diagram

```
messaging_priorities
    |
    +----< discovery_schedules (priority_id)
    |           |
    |           +----< discovered_pain_points (schedule_id)
    |                       |
    |                       +----< competitive_research (pain_point_id)
    |                       |
    |                       +----< messaging_gaps (pain_point_id)
    |
    +----< discovered_pain_points (priority_id)
    |
    +----< competitive_research (priority_id)
    |
    +----< messaging_assets (priority_id)
    |
    +----< messaging_gaps (priority_id)

voice_profiles
    |
    +----< generation_jobs (voice_profile_id)
    |
    +----< messaging_assets (voice_profile_id)
    |
    +----< asset_traceability (voice_profile_id)
    |
    +----< asset_variants (voice_profile_id)

generation_jobs
    |
    +----< messaging_assets (generation_job_id)

messaging_assets
    |
    +----< persona_scores (asset_id)
    |
    +----< asset_traceability (asset_id)
    |
    +----< asset_variants (original_asset_id)
    |
    +----< messaging_gaps (addressed_by_asset_id)

persona_critics
    |
    +----< persona_scores (critic_id)

settings (standalone key-value store)
product_documents (referenced via JSON arrays in generation_jobs and asset_traceability)
```

**Note on JSON references**: Several relationships are stored as JSON arrays within TEXT columns rather than as foreign key joins. This applies to:
- `generation_jobs.pain_point_ids` (many-to-many with discovered_pain_points)
- `generation_jobs.product_doc_ids` (many-to-many with product_documents)
- `generation_jobs.research_ids` (many-to-many with competitive_research)
- `asset_traceability.pain_point_ids`, `product_doc_ids`, `research_ids`
- `messaging_gaps.related_asset_ids`, `suggested_asset_types`

This is a deliberate trade-off: SQLite does not natively support array types, and creating junction tables for every many-to-many relationship would add significant complexity for limited benefit in a single-user admin tool. The JSON approach keeps the schema simpler while still enabling traceability.

---

## Table Origins

| Table | Origin | Notes |
|-------|--------|-------|
| `messaging_priorities` | New | No equivalent in source projects |
| `discovery_schedules` | o11y.tips | Adapted from `source_schedules` — added `priority_id`, changed config structure |
| `discovered_pain_points` | o11y.tips | Adapted from `discovered_tips` — reoriented from tips to pain points, added severity/relevance scoring |
| `generation_jobs` | New | No equivalent — generation is the core new capability |
| `settings` | o11y.tips | Nearly identical pattern, same key-value approach |
| `product_documents` | New | No equivalent in source projects |
| `messaging_assets` | New | Core output table, no equivalent |
| `persona_critics` | o11y.tips | Adapted from `quality_critics` — reframed as persona-based critics |
| `persona_scores` | o11y.tips | Adapted from `quality_scores` — added dimension-based scoring |
| `competitive_research` | compintels | Adapted from `research_jobs` — added pain point linkage, structured parsing |
| `asset_traceability` | New | Core differentiator, no equivalent |
| `messaging_gaps` | New | Gap analysis is new capability |
| `voice_profiles` | New | No equivalent in source projects |
| `asset_variants` | New | No equivalent in source projects |

---

## Index Recommendations

Create these indexes for optimal query performance:

```sql
-- Discovery lookups
CREATE INDEX idx_pain_points_status ON discovered_pain_points(status);
CREATE INDEX idx_pain_points_priority ON discovered_pain_points(priority_id);
CREATE INDEX idx_pain_points_severity ON discovered_pain_points(severity_score DESC);
CREATE INDEX idx_pain_points_source_type ON discovered_pain_points(source_type);
CREATE INDEX idx_pain_points_created ON discovered_pain_points(created_at DESC);

-- Schedule lookups
CREATE INDEX idx_schedules_enabled ON discovery_schedules(enabled);
CREATE INDEX idx_schedules_source_type ON discovery_schedules(source_type);

-- Asset lookups
CREATE INDEX idx_assets_status ON messaging_assets(status);
CREATE INDEX idx_assets_type ON messaging_assets(asset_type);
CREATE INDEX idx_assets_voice ON messaging_assets(voice_profile_id);
CREATE INDEX idx_assets_priority ON messaging_assets(priority_id);
CREATE INDEX idx_assets_score ON messaging_assets(overall_score DESC);
CREATE INDEX idx_assets_job ON messaging_assets(generation_job_id);
CREATE INDEX idx_assets_created ON messaging_assets(created_at DESC);

-- Scoring lookups
CREATE INDEX idx_scores_asset ON persona_scores(asset_id);
CREATE INDEX idx_scores_critic ON persona_scores(critic_id);
CREATE INDEX idx_scores_dimension ON persona_scores(dimension);
CREATE INDEX idx_scores_asset_dimension ON persona_scores(asset_id, dimension);

-- Research lookups
CREATE INDEX idx_research_status ON competitive_research(status);
CREATE INDEX idx_research_pain_point ON competitive_research(pain_point_id);

-- Traceability lookups
CREATE INDEX idx_traceability_asset ON asset_traceability(asset_id);

-- Gap lookups
CREATE INDEX idx_gaps_status ON messaging_gaps(status);
CREATE INDEX idx_gaps_severity ON messaging_gaps(severity);
CREATE INDEX idx_gaps_pain_point ON messaging_gaps(pain_point_id);

-- Variant lookups
CREATE INDEX idx_variants_original ON asset_variants(original_asset_id);
CREATE INDEX idx_variants_preferred ON asset_variants(is_preferred);

-- Generation job lookups
CREATE INDEX idx_jobs_status ON generation_jobs(status);
CREATE INDEX idx_jobs_voice ON generation_jobs(voice_profile_id);
CREATE INDEX idx_jobs_created ON generation_jobs(created_at DESC);
```

These indexes cover the most common query patterns: filtering by status, ordering by score or date, and joining on foreign keys. In SQLite, indexes are especially important because there is no query optimizer as sophisticated as PostgreSQL's — explicit indexes make a meaningful difference for tables that grow beyond a few thousand rows.
